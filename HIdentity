print("⏺️ Running Identity Test")
print("\n")
print("⏺️ Checking Capabilities")

local VERSION = "1.2.8"
function generateHash(length)
	local charset = {}
	for i = 48, 57 do table.insert(charset, string.char(i)) end -- 0-9
	for i = 65, 90 do table.insert(charset, string.char(i)) end -- A-Z
	for i = 97, 122 do table.insert(charset, string.char(i)) end -- a-z
	local hash = {}
	for i = 1, length do
		local rand = math.random(1, #charset)
		table.insert(hash, charset[rand])
	end
	return table.concat(hash)
end
local HASH = generateHash(8)

local function try(fn)
	local success, result = pcall(fn)
	local statusEmoji = success and "✅" or "⛔"
	local message = statusEmoji
	if success then
		--print(message)
	else
		--warn(message)
	end
	return success
end

function runTestsForLevel(tests)
	local results = {}
	for _, test in ipairs(tests) do
		table.insert(results, try(test.fn))
	end
	return results
end

local tests = {
	[1] = {
		{ fn = function() return game:GetService("CoreGui").Name end },
	},
	[3] = {
		{ fn = function() return game.DataCost end },
	},
	[4] = {
		{ fn = function() Instance.new("Player") end }
	},
	[6] = {
		{ fn = function() return Instance.new("SurfaceAppearance").TexturePack end },
		{ fn = function() return game:GetService("PlayerEmulatorService").SerializedEmulatedPolicyInfo end },
		{ fn = function() return game:GetService("VoiceChatService").UseNewControlPaths end },
		{ fn = function() return game:GetService("VoiceChatService").UseNewJoinFlow end },
		{ fn = function() return game:GetService("ServiceVisibilityService").HiddenServices end },
	},
	[7] = {
		{ fn = function() Instance.new("MeshPart").HasJointOffset = false end },
		{ fn = function() Instance.new("MeshPart").HasSkinnedMesh = false end },
		{ fn = function() Instance.new("MeshPart").MeshId = "" end },
		{ fn = function() game:GetService("Players").LocalPlayer.GameplayPaused = false end },
		{ fn = function() game:GetService("Chat").LoadDefaultChat = nil end },
	},
	[8] = {
		{ fn = function() Instance.new("MeshPart").HasJointOffset = false end },
		{ fn = function() Instance.new("MeshPart").HasSkinnedMesh = false end },
		{ fn = function() Instance.new("MeshPart").MeshId = "" end },
		{ fn = function() game:GetService("Players").LocalPlayer.GameplayPaused = false end },
		{ fn = function() game:GetService("Chat").LoadDefaultChat = nil end },
	},
}

local function all(tbl)
	for _, v in ipairs(tbl) do
		if not v then return false end
	end
	return true
end

function testidentity(tests)
	for level = #tests, 1, -1 do
		local levelTests = tests[level]
		if levelTests then  -- Check if levelTests is not nil
			local results = runTestsForLevel(levelTests)

			if all(results) then
				print(string.format("⏺️ Test Identity Detected: %d", level))
				return level
			end
		else
			warn(string.format("⛔ No tests found for level %d.", level))
		end
	end
	warn("⛔ Identity could not be determined.")
	return nil
end


local realIdentityLevel = testidentity(tests)

if typeof(getthreadidentity) == "function" then
	local printIdentityLevel = getthreadidentity()
	print("⏺️ Executor Identity: " .. printIdentityLevel)

	if realIdentityLevel then
		if printIdentityLevel ~= realIdentityLevel then
			warn("⚠️ Executor Identity does not match the Test Identity.")
			warn(string.format("⚠️ Possible identity spoofing detected | Executor Identity: %d | Test Identity: %d", printIdentityLevel, realIdentityLevel))
		else
			print("✅ " .. identifyexecutor() .. " Identity matches the Test Identity:", realIdentityLevel)
		end
	else
		warn("⛔ Failed to retrieve identity.")
	end
else
	if realIdentityLevel then
		print("✅ Test Identity: " .. realIdentityLevel)
	else
		warn("⛔ Failed to retrieve identity.")
	end
end

print("\n")
print("HIdentity, " .. VERSION .. " " .. HASH)
